KOA

https://github.com/koajs/static

https://github.com/koajs/examples/blob/master/upload/public/404.html

https://github.com/koajs/examples/tree/master/upload

JAVASCRIPT

const file = ctx.request.files.file;
const reader = fs.createReadStream(file.path);
const stream = fs.createWriteStream(path.join(os.tmpdir(), Math.random().toString()));
reader.pipe(stream);
console.log('uploading %s -> %s', file.name, stream.path);

https://github.com/koajs/examples/blob/master/upload/app.js

POST, FETCH

https://stackoverflow.com/questions/6396101/pure-javascript-send-post-data-without-a-form

const data = { username: 'example' };

fetch('https://example.com/profile', {
  method: 'POST', // or 'PUT'
  headers: {
 '           Content-Type': 'application/json',
           },
  body: JSON.stringify(data),
})
  .then(response => response.json())
  .then(data => {
      console.log('Success:', data);
     })
 .catch((error) => {
         console.error('Error:', error);
   });
   
HTML

https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html

document.addEventListener("DOMContentLoaded", function(event) { 

console.log('DOMContentLoaded');


https://www.tutorialrepublic.com/faq/how-to-get-the-value-of-text-input-field-using-javascript.php


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Get Text Input Field Value in JavaScript</title>
</head>
<body>
    <input type="text" placeholder="Type something..." id="myInput">
    <button type="button" onclick="getInputValue();">Get Value</button>
    
    <script>
        function getInputValue(){
            // Selecting the input element and get its value 
            var inputVal = document.getElementById("myInput").value;
            
            // Displaying the value
            alert(inputVal);
        }
    </script>
</body>
</html>


K8S SERVICE

https://cloud.google.com/kubernetes-engine/docs/concepts/service

KUBERNETES

k3d kubectl yaml Service spec template labels backend Ingress selector ports containers image


PUG

https://nicedoc.io/pugjs/pug


Kubernetes k8s

DOCKER REMOVE

$ sudo apt-get remove docker-ce docker-ce-cli

$ sudo apt-get remove docker-compose

$ sudo apt-get remove docker docker-engine docker.io containerd runc

$ sudo apt-get update


DOCKER

$ sudo apt-get install docker-ce docker-ce-cli docker-compose

$ docker info | grep -i cgroup

$ sudo systemctl status docker.service


k3d

$ k3d cluster delete


$ k3d cluster create --port 8082:30080@agent:0 -p 8081:80@loadbalancer --agents 2


kubectl

$ k3d cluster create -a 2

$ kubectl get po -A

$ kubectl cluster-info

$ k3d cluster stop

$ k3d cluster start

$ k3d cluster delete

$ kubectl get po -A

how to install kubectl?

$ stable=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)

$ curl -LO https://storage.googleapis.com/kubernetes-release/release/${stable}/bin/linux/amd64/kubectl

$ chmod +x ./kubectl

$ sudo mv ./kubectl /usr/local/bin/kubectl

If kubectl cluster-info returns the url response but you can't access your cluster, to check whether it is configured properly, use:

$ kubectl cluster-info

https://devopswithkubernetes.com/part-0#installing-k3d

k3d

$ k3d version

$ curl -s https://raw.githubusercontent.com/rancher/k3d/main/install.sh | bash

https://github.com/rancher/k3d#get

$ sudo chmod go+xr /usr/local/bin/k3d

$ k3d help

$ echo $PATH

$ export PATH="/usr/bin/k3d/:$PATH"

Open the ~/.bashrc file or ~/.profile

Add the following line

export PATH="/usr/bin/k3d/:$PATH"

Use the source command to force Linux to reload the .bashrc file

$ source .bashrc

$ k3d node list

$ k3d cluster delete

$ k3d cluster list

$ kubectl cluster-info

$ k3d cluster create --config config.yaml

https://k3d.io/usage/configfile/

Part 1

https://devopswithkubernetes.com/part-1/1-first-deploy

REMOVE DOCKER NETWORKS

$ docker network prune

REMOVE DOCKER IMAGES

Remove all images at once

$ docker rmi $(docker images -q)

Remove multiple images

$ docker rmi <IMAGE-ID> <IMAGE-ID> ...

DOCKER REMOVE CONTAINER

$ docker rm <IMAGE-ID> or <CONTAINER-NAME>

Stop all running containers

$ docker stop $(docker ps -a -q)

Delete all stopped containers

$ docker rm $(docker ps -a -q)

DOCKER OPTIONS

$ docker ps -a -q

docker ps = list containers

-a the option to list all containers, even stopped ones. Without this, it defaults to only listing running containers

-q the quiet option to provide only container numeric IDs, rather than a whole table of information about containers


EXERCISES

https://github.com/kubernetes-hy/material-example/tree/master/app1

K8S

$ kubectl create deployment hashgenerator-dep --image=<USER_NAME>/dwk-app1
  
$ kubectl explain pod

$ kubectl get deployments

You can use `source <(kubectl completion bash)` to save .bashrc for an automatic load.

DOCKER REPOSITORY

https://hub.docker.com/

Click Create a Repository on the Docker Hub

<your-username>/my-private-repo

Set the visibility to Private.

Dockerfile

https://github.com/kubernetes-hy/material-example/blob/master/app1/Dockerfile

DOCKER BUILD

The docker build command builds an image from a Dockerfile.

$ docker build -t <your_username>/my-private-repo .


PUBLISH DOCKER IMAGE

$ docker login

Tag the image

$ docker tag example_image:latest gauravvv/example_image:latest

DOCKER PUSH IMAGE TO DOCKER HUB

$ docker push <your_username>/my-private-repo 

$ docker push gauravvv/example_image:latest

or

$ docker commit -m "Added LAMP Server" -a "NAME" test-lamp-server USER/test-lamp-server:latest

Your repository in Docker Hub should now display a new latest tag under Tags

Search the Docker Hub for Images

$ docker search <image_name>

Pull an Image or a Repository from a Registry

$ docker pull <image_name>:<tag_name>

PULL DOCKER IMAGE FROM REPOSITORY

If you want to test out your image, use the below command and launch a container from it:

$ docker pull <image_name>:latest

$ docker run -it <image_name>:latest

or

docker run --name test-server -it <image_name>:latest bash

DOCKER EXEC SHELL

$ docker exec -it <mycontainer> bash

To deploy an application we'll need to create a Deployment object with the image.

$ kubectl create deployment hashgenerator-dep --image=jakousa/dwk-app1
  deployment.apps/hashgenerator-dep created

$ docker --version

$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

$ sudo add-apt-repository   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) \
  stable"

$ sudo apt-get update

$ sudo apt-get install docker-ce

$  docker --version

$  expressvpn disconnect

$  k3d cluster create mycluster

$  k3d cluster delete

$  k3d cluster create -a 2

DOCKER IMAGE TAGS

By using tags (e.g. dwk/image:tag) with the k8s deployments

Exercise 1.01

$ docker stop $(docker ps -a -q)

$ docker rm $(docker ps -a -q)

$ docker rmi $(docker images -q)

$ sudo ufw allow 6443/tcp

$ sudo ufw allow 2379/tcp

$ sudo ufw allow 2380/tcp

$ sudo ufw allow  10248/tcp

$ sudo ufw allow 10250/tcp

$ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg

$ sudo nano /etc/apt/sources.list.d/kubernetes.list

$ echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list

$ sudo apt-get update

$ sudo apt-get install -y kubelet kubeadm kubectl

$ sudo apt-mark hold kubelet kubeadm kubectl

$ sudo swapoff -a

$ sudo sed -i '/ swap / s/^/#/' /etc/fstab

$ docker info | grep -i cgroup

$ sudo chmod a+rwx /etc/systemd/system/kubelet.service.d/10-kubeadm.conf

$ sudo echo 'Environment="KUBELET_EXTRA_ARGS=--fail-swap-on=false"' >> /etc/systemd/system/kubelet.service.d/10-kubeadm.conf

$ cd /etc/systemd/system/kubelet.service.d

$ sudo nano 10-kubeadm.conf 

[Service]
Environment="KUBELET_CGROUP_ARGS=--cgroup-driver=systemd"

$ sudo chmod a+rx /etc/systemd/system/kubelet.service.d/10-kubeadm.conf

$ cd /etc/systemd/system/kubelet.service.d

$ sudo touch 20-allow-swap.conf

$ sudo chmod a+rx 20-allow-swap.conf

$ sudo nano 20-allow-swap.conf

[Service] 
Environment="KUBELET_EXTRA_ARGS=--fail-swap-on=false”

$ sudo chmod a+rx 20-allow-swap.conf

$ sudo nano /etc/docker/daemon.json

$ cat /etc/docker/daemon.json
{
    "dns": ["192.168.31.1", "10.0.0.2", "8.8.8.8"],
    "exec-opts": ["native.cgroupdriver=systemd"]
}

$ sudo systemctl daemon-reload

$ sudo systemctl restart docker

$ sudo systemctl status docker.service

$ sudo kubeadm reset

$ sudo kubeadm init --pod-network-cidr=10.244.0.0/16

$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

$ sudo chown $(id -u):$(id -g) /etc/kubernetes/admin.conf

$ sudo chown $(id -u):$(id -g) $HOME/.kube/config

$ export KUBECONFIG=$HOME/.kube/config

$ echo "export KUBECONFIG=/etc/kubernetes/admin.conf" >> ~/.bashrc

$ echo "export KUBECONFIG=/etc/kubernetes/admin.conf" >> ~/.profile

$ sudo nano ~/.bashrc

$ source ~/.bashrc

$ sudo chown -R $USER $HOME/.kube

$ sudo systemctl status kubelet

$ sudo kubectl version

$ sudo kubectl cluster-info

$ netstat -pnlt | grep 6443

$ docker login

$ docker build -t <USER_NAME>/app-0:1.01 .

$ docker push <USER_NAME>/my-private-repo 


The push refers to repository [docker.io/jylhakos/app-1]

$ kubectl create deployment app-0-dep --image=jylhakos/app-0:1.01

$ journalctl -e


https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/

Create an application that generates a random string on startup, stores this string into memory, and outputs it every 5 seconds with a timestamp

Deploy it into your Kubernetes cluster and confirm that it's running with kubectl logs.

To deploy we need the cluster to have an access to the image.

To deploy an application we'll need to create a Deployment object with the image.

Deployment

https://kubernetes.io/docs/concepts/workloads/controllers/deployment/

$ kubectl create deployment app-1.02 --image=test/app-1.02

$ kubectl get deployments

$ kubectl get pods

  
Exercise 1.02: Project v0.1

Create a web server that outputs "Server started in port NNNN" when it's started and deploy it into your Kubernetes cluster. 


Exercise 1.05

Connecting from outside of the cluster

$ kubectl get pods

NAME                                READY   STATUS    RESTARTS   AGE
hashresponse-dep-57bcc888d7-dj5vk   1/1     Running   0          19h

$ kubectl port-forward hashresponse-dep-57bcc888d7-dj5vk 3003:3000

  Forwarding from 127.0.0.1:3003 -> 3000
 
Use kubectl port-forward to confirm that the project is accessible and works in the cluster by using a browser to access the project.

Open page from http://localhost:3003

$ kubectl get pods

$ kubectl port-forward app--57bcc888d7-dj5vk 3003:3000

Exercise 1.06

https://devopswithkubernetes.com/part-1/3-introduction-to-networking

$ k3d cluster delete

$ k3d cluster create --port 8082:30080@agent:0 -p 8081:80@loadbalancer --agents 2

$ kubectl apply -f https://raw.githubusercontent.com/kubernetes-hy/material-example/master/app2/manifests/deployment.yaml


Exercise 1.09

https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/

Ingress is the most useful if you want to expose multiple services under the same IP address, and these services all use the same L7 protocol (typically HTTP). 

https://kubernetes.io/docs/concepts/services-networking/ingress/

An example where an Ingress sends all its traffic to one Service

https://www.cortex.io/post/understanding-kubernetes-services-ingress-networking

GKE

https://cloud.google.com/kubernetes-engine/docs/how-to/load-balance-ingress

Add the following line to the bottom of the /etc/hosts file on your computer (you will need administrator access):

$ sudo nano /etc/hosts

$ curl hello-world.info

172.17.0.15 hello-world.info

https://stackoverflow.com/questions/63820564/kubernetes-how-to-subdomain-localhost-using-nginx-ingress-controller

Creating a Kubernetes Ingress

First, let’s create two services to demonstrate how the Ingress routes our request. We’ll run two web applications that output a slightly different response.

kind: Service
apiVersion: v1
metadata:
  name: apple-service
spec:
  selector:
    app: bus
  ports:
    - port: 5678
    
    
kind: Service
apiVersion: v1
metadata:
  name: banana-service
spec:
  selector:
    app: subway
  ports:
    - port: 5678
   
Create the resources

$ kubectl apply -f bus.yaml

$ kubectl apply -f subway.yaml
 
Now, declare an Ingress to route requests to /bus to the first service, and requests to /subway to second service.

apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: example-ingress
  annotations:
    ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
        - path: /bus
          backend:
            serviceName: bus-service
            servicePort: 5678
        - path: /subway
          backend:
            serviceName: subway-service
            servicePort: 5678
            
Create the Ingress in the cluster

$ kubectl create -f ingress.yaml

$ curl -kL http://localhost/bus

$ curl -kL http://localhost/subway

https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ingress-guide-nginx-example.html
        
Then Start by creating the “mandatory” resources for Nginx Ingress in your cluster.

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml

Then, enable the ingress add-on for Minikube.

minikube addons enable ingress


